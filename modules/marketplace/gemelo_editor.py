# modules/marketplace/gemelo_editor.py

import json
import streamlit as st
from modules.marketplace.validacion import validar_plan_local
from modules.marketplace.ai_engine import get_ai_response

def editor_tabiques(plan_json, superficie_finca):
    """
    Componente de edici√≥n de tabiques que permite ajustar m¬≤ por estancia.
    Usa st.data_editor para edici√≥n interactiva manteniendo nombres fijos.

    Args:
        plan_json: Plan actual con habitaciones
        superficie_finca: Superficie total de la finca

    Returns:
        tuple: (plan_json_actualizado, resultado_validacion)
    """
    st.subheader("‚úèÔ∏è Editar tabiques (m¬≤ por estancia)")

    # Construir dataframe simple para edici√≥n
    filas = []
    for h in plan_json.get("habitaciones", []):
        filas.append({
            "nombre": h.get("nombre", "Estancia"),
            "m2": float(h.get("m2", 0))
        })

    # Editor de datos con nombres deshabilitados
    edited = st.data_editor(
        filas,
        num_rows="dynamic",
        column_config={
            "nombre": st.column_config.TextColumn("Estancia", disabled=True),
            "m2": st.column_config.NumberColumn("m¬≤", min_value=1.0, step=0.5)
        },
        use_container_width=True
    )

    # Aplicar cambios al JSON (solo m2)
    for i, h in enumerate(plan_json.get("habitaciones", [])):
        if i < len(edited):
            h["m2"] = float(edited[i]["m2"])

    # Recalcular total_m2
    total = 0
    for h in plan_json.get("habitaciones", []):
        total += float(h.get("m2", 0))
    if "garage" in plan_json:
        total += float(plan_json["garage"].get("m2", 0))
    plan_json["total_m2"] = total

    # Validaci√≥n local
    resultado = validar_plan_local(plan_json, superficie_finca)

    # Mostrar validaciones
    st.markdown("### üìè Validaci√≥n local (reglas gen√©ricas)")
    if resultado["ok"]:
        st.success(".1f"".1f")
    else:
        for e in resultado["errores"]:
            st.error(e)

    for r in resultado["recomendaciones"]:
        st.info(r)

    return plan_json, resultado


def evaluar_con_ia(plan_json, superficie_finca):
    """
    Eval√∫a el plan con IA y propone ajustes seg√∫n normas gen√©ricas.

    Args:
        plan_json: Plan actual
        superficie_finca: Superficie de la finca

    Returns:
        str: An√°lisis y propuestas de la IA
    """
    total = plan_json.get("total_m2", 0)
    if total == 0:
        total = sum(float(h.get("m2", 0)) for h in plan_json.get("habitaciones", [])) + \
                (float(plan_json["garage"].get("m2", 0)) if "garage" in plan_json else 0)

    prompt = f"""
Eres un asistente de arquitectura para un MVP. Normas gen√©ricas:
- Dormitorios ‚â• 8 m¬≤ (recomendado ‚â• 10 m¬≤).
- Sal√≥n/Comedor ‚â• 12 m¬≤ (recomendado ‚â• 18 m¬≤).
- Cocina ‚â• 6 m¬≤.
- Ba√±o ‚â• 3 m¬≤.
- Superficie construida ‚â§ 33% de la finca.

Finca: {superficie_finca:.1f} m¬≤. M√°ximo construible: {superficie_finca*0.33:.1f} m¬≤.
Plan actual (JSON): {json.dumps(plan_json, ensure_ascii=False)}

Tarea:
1) Indica qu√© estancias NO cumplen y por qu√©.
2) Prop√≥n ajustes concretos de m¬≤ por estancia para cumplir (sin superar el 33%).
3) Si alg√∫n dormitorio queda en 6 m¬≤, explica que solo ser√≠a v√°lido como despensa/trastero en este MVP.
4) Devuelve un JSON de propuesta ajustada con habitaciones (nombre, m2), garage y total_m2.
"""

    try:
        analisis = get_ai_response(prompt)
        return analisis
    except Exception as e:
        return f"Error al consultar IA: {str(e)}. Verifica configuraci√≥n de API."


def aplicar_propuesta_ia(informe_ia_texto: str, plan_json_actual: dict):
    """
    Intenta aplicar una propuesta de IA parseando JSON del informe.

    Args:
        informe_ia_texto: Texto del informe IA
        plan_json_actual: Plan actual como fallback

    Returns:
        dict: Plan actualizado o el actual si no se pudo parsear
    """
    try:
        # Buscar JSON en el texto (puede estar entre ```json y ```)
        import re
        json_match = re.search(r'```json\s*(\{.*?\})\s*```', informe_ia_texto, re.DOTALL)
        if json_match:
            propuesta = json.loads(json_match.group(1))
            return propuesta
        else:
            # Intentar parsear todo el texto como JSON
            propuesta = json.loads(informe_ia_texto)
            return propuesta
    except json.JSONDecodeError:
        st.warning("La IA devolvi√≥ texto no JSON. Revisa el informe manualmente.")
        return plan_json_actual